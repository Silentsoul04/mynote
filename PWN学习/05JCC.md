## JMP指令

前提：EIP寄存器存放的是程序下一次需要执行的指令地址，不可随意更改。本节差不多就是理解如何“更改”EIP的值



### JMP

jmp指令可以操作程序跳到一个指令的地址（单次，不返回）。其实就是仅仅只修改EIP的值，控制程序跳转

**格式：**MOV EIP,寄存器/立即数		简写为：		**JMP 寄存器/立即数**

**示例：**

```
JMP EAX
JMP 0x004183FA
```



### CALL&RETN

**CALL和JMP一样，都为跳转指令。但是会进行两步操作：**

1. 将下一条指令的所在地址（即当时程序计数器PC的内容）入栈
2. 并将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序）

可以理解为：

- ```
  PUSH 地址B		//将地址B压入栈（地址B为call指令的不跳转下一步地址，可以理解为原位置的下一步地址）
  ```

- ```
  MOV EIP,地址A/寄存器			//同JMP一样，修改EIP的值进行跳转
  ```

**RETN指令常和CALL指令一起使用，用于跳出后的返回：**

1. 读取栈顶的地址（CALL指令将原位置的下一步地址存入栈顶）
2. POP弹出栈顶的值到EIP（POP EIP，指令不允许，但是同一个意思），从而修改EIP的值，进行跳转后的返回



**格式：**【PUSH 地址B  +  MOV EIP,地址A/寄存器】       简写为：         CALL 地址A/寄存器

**示例：**

```
CALL EAX
CALL 0x004183FE

RETN
```



### RET&RETF指令

**ret指令**用栈中的数据，修改IP的内容，从而实现**近转移**；
**retf指令**用栈中的数据，修改CS和IP的内容，从而实现**远转移**。

**格式：**【LEA ESP,[ESP+4]	+	MOV EIP，[ESP-4]】	简写为：	RET

给ESP寄存器的值加上4（堆栈弹出一个32位数据），给EIP寄存器赋弹出的值作为下一条指令的地址





## 比较指令



### CMP指令

**作用：**用于比较两个操作数，相当于SUB（减法）指令，但是相减的结构并不保存到第一个操作数中，只是根据相减的结果来改变零标志位的，**当两个操作数相等的时候，Z标志位置1；当不等式时，S位为1则第一个是大于第二个数，反之则小于**

**格式：**CMP  R/M,R/M/IMM

**示例：**

```
MOV EAX,100
MOV ECX,100
CMP EAX,ECX			//观察Z位（零标志）	比较相等，相等为1

MOV EAX,100
MOV ECX,200
CMP EAX,ECX			//观察S位（符号标志）	第一个大于第二个就为1，反之为0

CMP AX,WORD PTR DS:[405000]
```

**注意：**

1. 不能同时CMP指令不能 内存 -- 内存 比较





### TEST指令

**作用：**两个数值进行**与操作**，结果不保存，但是会改变相应标志位

**常见用法：**用这个指令，**可以确定某寄存器是否为空等于0**，结果通过**观察标志位Z位得出**

**示例：**

```
TEST EAX,EAX		//观察Z位
```

**注意：**

1. 但是如果EAX的二进制某些位为1的话，那么运算的结果就不为零





## JCC指令

| JCC指令     | 中文含义                                | 检查符号位       | 典型C应用                |
| ----------- | --------------------------------------- | ---------------- | ------------------------ |
| JZ/JE       | 若结果为0则跳转（**相等则跳转**）       | ZF=1             | if (i == j);if (i == 0); |
| JNZ/JNE     | 若结果不为0则跳转（若**不相等则跳转**） | ZF=0             | if (i != j);if (i != 0); |
| JS          | 若为负则跳转                            | SF=1             | if (i < 0);              |
| JNS         | 若为正则跳转                            | SF=0             | if (i > 0);              |
| JP/JPE      | 若结果中**1出现次数为偶数则跳转**       | PF=1             | (null)                   |
| JNP/JPO     | 若结果中**1出现次数为奇数则跳转**       | PF=0             | (null)                   |
| JO          | 若结果溢出则跳转                        | OF=1             | (null)                   |
| JNO         | 若结果无溢出则跳转                      | OF=0             | (null)                   |
| JC/JB/JNAE  | **小于**则跳转 (无符号数)               | CF=1             | if (i < j);              |
| JNC/JNB/JAE | **大于等于**则跳转 (无符号数)           | CF=0             | if (i >= j);             |
| JBE/JNA     | **小于等于**则跳转 (无符号数)           | ZF=1或CF=1       | if (i <= j);             |
| JNBE/JA     | **大于**则跳转(无符号数)                | ZF=0或CF=0       | if (i > j);              |
| JL/JNGE     | **小于**则跳转 (有符号数)               | SF != OF         | if (si < sj);            |
| JNL/JGE     | **大于等于**则跳转 (有符号数)           | SF = OF          | if (si >= sj);           |
| JLE/JNG     | **小于等于**则跳转 (有符号数)           | ZF != OF 或 ZF=1 | if (si <= sj);           |
| JNLE/JG     | **大于**则跳转(有符号数)                | SF=0F 且 ZF=0    | if(si>sj)                |









