# PHP

下载地址：[PHP 下载](https://www.php.net/)

## 安装

1. 配置Apache使可以调用PHP

   在apache主配置文件（httpd.conf）中添加以下两行。

   在大约180行后（在apache默认模块后面添加PHP模块），添加如下两行

   ``` 
   #添加php7模块
   LoadModule php7_module "C:/wanp/php/php7apache2_4.dll"这个文件的完整路径
   #添加（设定）php文件的后缀
   AddType Application/x-httpd-php .php
   ```
   
   重启apache
   
2. 更改默认php的时区

   首先将php目录下的"php.ini-development"文件改为"php.ini"

   打开找到 "[Date]" （大约920行），将timezone设为 PRC

   ```
   #去掉;的注释，加上“PRC”代表中国的标识
   date.timezone = PRC
   ```

3. 设置 php.ini 的文件路径

   在apache的主配置中的PHP模块后再加这一行

   ```
#注意只要路径
   PHPIniDir "C:/wanp/php"
   ```
   
4. 连接MySQL

   - php.ini 中，设置php模块位置（找关键字extension_dir = "ext"）

     ```
     #修改路径为php的ext的文件夹路径，大约757行
     extension_dir = "C:/wanp/php/ext"
     ```

   - php.ini 中，开启mysql模块（只是去注释，关键字php_mysql）

     ```
     #新版中，关键字为mysqli，大约922行
     extension=mysqli
     ```

   - 安装mysql数据库并配置（就是进行安装）



## PHP基本语法规则

### PHP标记

1. 推荐写法

   ```php
   <?php   php的代码写在这里   ?>
   ```

2. 正确写法

   ```php
   <script language="php">   PHP代码写在这里	 </script>
   ```

3. 也可以这么写，但需要到php.ini中进行**配置：**short_tag = On

   默认为OFF，表示**默认不能这么写**

   ```php
   <?   php的代码写在这里   ?>
   ```



### PHP语句结束

使用英文分号（;）表示一条语句的结束



### PHP注释

#### 单行注释

两个斜杠：//

#### 多行注释

```php
/*
	注释内容
	可以多行注释
*/

/*	这样也是可以的	 */
```



### 数据连接

```php
echo "<br>n1=" . $n1;	//.连接，输出一个数据
echo "<br>n1=" , $n1;	//，多个，输出多个数据
```



## 变量

规定变量前加上**"$"**，**定义形式：$变量名 = 数据**，**变量名区分大小写**！

```php
<?php
$x = 1;
$y = 1;
$z = $x + $y;

echo $z;
echo $x, $y, $z;
?>
```

### 命名规则

1. 构成：字母、数字、下划线；

2. 开头：字母或下划线（不能以数字开头）；

**注意：**变量名不要跟系统中的“关键字”（即语法所用单词）重复——关键字不多，也就几十个。

可能的报错信息：

1. Undefined variable		未定义的变量



### 变量操作

1. 赋值
2. 取值
3. 判断变量 isset()
4. 删除/销毁变量 unset()

```php
$v1 = 1;
$v2 = 2;
$v3 = isset($v1);

echo $v3;	//输出简单信息，例：ture时，输出1
var_dump $v3;  	//输出变量的完整信息，例：ture时，输出bool(ture)

unset($v1);		//删除$v1
$v4 = isset($v1);
var_dump($v1);		//输出bool(false)
```



### 赋值

**值传递之后，两个变量互不影响，相互独立，没有关系了！**

```php
$v1 = 10;
$v2 = $v1;	//传值

echo "<br>v2为：", $v2;	//10

$v1 = 20;	//改变v1的值
echo "<br>v2为：", $v2;	//10
```



### 引用传递（地址传递）

将右边变量对数据的**引用关系**，传给左边的变量，类似于在数据空间上**”贴上两个变量标签“** ，他们都指向同一个数据

在引用传值后，两个变量是一样的，**改变其中一个，另一个也该改变！**

```php
$v1 = 10;
$v2 = &$v1;		//赋值时加了一个引用符号“&”，叫做引用传值

echo "<br>v2为：", $v2;	//10

$v1 = 20;	//改变v1的值
echo "<br>v2为：", $v2;	//20

$v2 = 30;	//改变v2的值
echo "<br>v1为：", $v1;	//30
```



### isset(); 判断变量是否存在

返回**ture**或**false**

```php
isset('变量名');
```



### unset(); 删除/销毁变量

本质上就是将变量名与数据**断开连接关系**

```php
unset('变量名');
```



### 预定变量

在PHP语言内部，有一些（也就10来个）变量，是现成的，直接可以使用，这就是所谓预定义变量



#### $_GET[""]

代表浏览器表单通过“get”方式提交的**所有数据（集）**，可以称为“get数据”。

也可以理解为：

$_GET变量里面会“自动存储”（保存/装载）提交到某个文件中的GET数据。

而GET数据，是在一个页面以“get”方式请求的时候提交的数据。

**必须大写！**

HTML中：

```html
<form action="get_form_data.php" method="get">
    姓名：<input type="text" name="username">
	<br>
	年龄：<input type="text" name="age">
	<br>
	<input type="submit" value="提交">
</form>
```

PHP中：

```php
<?php 
$name = $_GET["username"];
$age = $_GET["age"];


echo "<br>姓名为：", $name;
echo "<br>年龄为：", $age;
?>
```



#### $_POST[""]

类似于$_GET[""]，代表浏览器表单通过“post”方式提交的**所有数据（集）**，可以称为“post数据”。



#### $_REQUEST[""]

代表浏览器通过“get”方式 或 “post”方式提交的数据的合集，即：它**既能**接收到get过来的数据，**也能**接收到post过来的数据！

通常，一个表单，只提交一种形式的数据，要么get数据，要么post数据！



**但，有一个情况，提交post数据的同时，也可以提交get数据**

action中的地址里的”？“后的数据是get数据，form表单中的各个表单项，就是post数据！

**有且只有这一种方法**

```html
	<form action="get_form_data.php?id=10&userName=antlers" method="post">
	姓名：<input type="text" name="username">
	<br>
	年龄：<input type="text" name="age">
	<br>
	<input type="submit" value="提交">
	<form>
```



#### $_SERVER[""]

它代表任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息，包括很多（10多项）

常用的有：

- PHP_SELF：         表示当前请求的网页地址（不含域名部分）
- SERVER_NAME：    表示当前请求的服务器名
- SERVER_ADDR：   表示当前请求的服务器IP地址
- DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）
- REMOTE_ADDR：  表示当前请求的客户端的IP地址
- SCRIPT_NAME：     表示当前网页地址



### 可变变量

**变量名本身又是一个“变量”的变量**

示例：

```php
$v1 = 10;

echo $v1;  //输出10

$str = “v1”;  //这是一个变量，名为str，值为“v1”（字符串）
echo $$str;  //输出10。这里，“$$str”就是所谓的“可变变量”

//相当于 echo $v1;  结果就是10


$a = 10;
$b = "a";
$c = "b";
echo $$$c;		//输出10，相当于$$b，相当于$a
```



```php 
$v1 = 1;
$v2 = 3;
$v3 = 21;
......

$result1 = $v1 + $v2 + $v3 + ...;	//方法一，适用于少量变量的计算

for($i = 1; $i<=100; $i++){		//用PHP中的可变变量+for循环简化过程
	$n = "v" . i;	//连接两个内容（字符）
	$result2 += $$n;
}
```



## 常量

常量，就是一个用于存储“不会（也不允许）变化的数据”的标识符。比如圆周率！

### define()

define(‘常量名’, 对应的常量值);	，**常量名推荐用“全大写”！**

### const 关键字

const 常量名 = 对应常量值;



### 取值

**方法一：直接使用**

```php
echo 常量名;
```

**注意：**常量在引用时，不需要像引用变量时加入“$”符号，**直接引用常量名就好了！**



**方法二：使用constant()函数取值**

```php
echo constant('常量名');
```

**注意：**此时常量名要用**引号引起来！**



### 判断常量是否存在：defined();

返回**ture**或**false**

```php
difind( '常量名' );
```

示例：

```php
if( !defined("PI1") ){		//如果常量PI1没有被定义过
    define("PI1", 3.14);	//那么在这里定义PI1
}

$s1 = PI1 * 2 * 2;		//直接使用常量PI1，计算半径为2的圆的面积
```



### 预定常量

预定义常量就是**PHP语言内部预先定义好的常量**，我们可以直接使用，类似于预定变量！

- PHP_VERSION：表示当前php版本信息
- PHP_OS：表示php运行所在的系统信息
- PHP_INT_MAX：表示当前版本的php中的最大整数值
- M_PI：表示圆周率“派”，精度为10多位小数



### 魔术常量

魔术常量也是常量，只是在**形式上为常量**，而其**值其实是“变化”的！**

他们也是系统中预先定义好的，也就几个，下面是最常用的 3个：

```php
__DIR__       ：代表当前php网页文件所在的目录
echo "当前php网页文件所在的目录路径：", __DIR__;

__FILE__      ：代表当前php网页文件本身的路径，路径到文件名
echo "当前php网页文件本身的路径：", __FILE__;

__LINE__,     ：代表当前这个常量所在的行号
echo "当前这一行所在的行号：", __LINE__;
```



## 数据类型

### 数据类型的分类

标量类型：

- 字符串类型	string
- 整数类型    integer   int
- 浮点数    double    float
- 布尔类型    boolean    bool

复合类型：

- 数组    array
- 对象    object

特殊类型：

- 空	null
- 资源类型    resource    表示一种外部的可供php使用（操作）的资源（比如照片，数据库，文件等）



### 整型 int

#### 书写类型

- 10进制形式：$n1 = 123
- 8进制形式：$n1 = 0123          //以0开头，只能出现0-7这8个数
- 16进制形式：$n1 = 0x12A34        //以0x开头，可以出现0-9，A-F这16个数字
- 2进制形式：$n1 = 0b1011011010        //以0b开头，只能出现0和1这2个数字

**注意：**输出还是十进制



#### 进制的转换

进制转换的单词：

- dec：10进制
- oct： 8进制
- hex： 16进制
- bin： 2进制



10进制转为2, 8, 16进制：

- decbin()：将10进制转为2进制
- decoct()：将10进制转为8进制
- dechex()：将10进制转为16进制

2, 8, 16进制转为10进制：

- bindec()：将2进制数字字符串转为10进制
- octdec()：将8进制数字字符串转为10进制
- hexdec()：将16进制数字字符串转为10进制



### 浮点型 float

#### 书写类型

- 常规形式（带小数点）：

  $f1 = 0.1;        	 //或者1.23;  123.0;

- 科学计数法形式（带e）：

  $f2 = 1.23e3;  	   //表示1.23 乘以10的3次方

  $f3 = 123e2;   	   //这个也是浮点数，虽然其结果值是一个“整数”（12300）

**特别注意：**

- **浮点数不要随便做相等比较（==）**：因为浮点数进行相等比较，是“不可靠”的

  ```php
  $v1 = 0.1
  $v2 = 0.2
  $v3 = 0.3
  
  if( $v3 == $v1 + $v2)
  {
  	echo "相等1"
  }
  else
  {
  	echo "不相等1"
  }
  
  //输出	不相等2
  ```

- **如果要比较大小**，需要在**考虑精度**（就例如例题10000）的基础上，将浮点数转换为整数，然后进行“比较大小”

  ```php
  $v1 = 0.1
  $v2 = 0.2
  $v3 = 0.3
  if( $v3 == $v1 + $v2)
  {   round($v3 * 10000) == round(($v1 + $v2 * 10000))
      echo "相等2"
  }
  else{    
      echo "不相等2"
  }
  
  //输出	“相等2”
  ```

  

### 布尔值 boolean

只有两个数据值：true，false（不区分大小写）



当做“布尔值”进行判断或比较的时候，**以下数据会被当作布尔值的 false**：

- false, 0, 0.0, “”,  null, ‘0’, 空数组

其余都被当做布尔值的 true



### 字符串型 string

字符串使用单引号或双引号来表示（引起来）

**举例：**

- 最短的字符串是“空字符串”，比如： $str1 = “” ；$str2 = ''		//但是这个与null不同！！！
- 这个不是空字符串：“ ”， 因为其中包括了1个空格字符
- $v1 = "false"       //表示字符串

**特别注意**：

- **双引号**字符串中，如果出现“$”符号，则该符号后的连续字符（单词）会被**识别为一个变量名**。但是**单引号内不会识别变量**

  - 如果识别成功（即确实存在该变量），则会将该变量转换为实际内容。

  - 如果识别失败（即实际没有该变量），则会报错。

  
  ```php
  $v1 = 12;
echo "<br>v1的值为：" . $v1;	//输出 v1的值为：12
  echo "<br>v1的值为：$v1";	//输出 v1的值为：12
  echo '<br>v1的值为：$v1';	//输出 v1的值为：$v1
  ```
  
  转义符 "\\"，输出 "$" 符号
  
  ```php
  echo '<br>\$v1的值为：$v1';	//输出 $v1的值为：$v1
  ```



### 数组类型 array

数组，就是将多个“数据”放在一起，排成一个有序序列，这个序列作为一个整体（里面包括了多个数据），就称为“数组”。比如：

```php
$info1 = array(‘张三丰’, 18, “男”);
$info2 = [‘张三丰’, 18, “男”];		//新版本另一种写法

或
    
$info3 = array(‘name’ => ‘张三丰’, ‘age’=>18, ‘gender’ => “男”);
$info4 = [‘name’ => ‘张三丰’, ‘age’=>18, ‘gender’ => “男”]		//新版本另一种写法
```



#### 数组的赋值&取值

- 数组的赋值：
  - $数组变量[下标] = 一个值；
- 数组的取值：
  - $数组变量[下标]
  - 举例：
    -  echo  $info1[0];      //输出$info1中下标为0的数据
    -  print_r( $info2[‘name’] )；  



### 空类型 null

$v1 = null;   	//此时，具有变量$v1,但其中的数据是“**空的**”（没有数据）

空值变量，isset()判断的结果是false（即不存在）。



### 数据类型的判断

#### gettype()：判断类型

获取一个变量的类型，结果为一个变量类型的名称（字符串）

```php
$v1 = 10;
$r1 = gettype( $v1 );	//结果为：“integer”
```

#### settype()：设置类型

设置一个变量的类型

```php
$v1 = 10;		//此时，$v1中数据是整数类型
settype( $v1, ‘string’);	//此时，$v1是字符串类型，即其中的数据变成了：“10”
echo  gettype( $v1 );	//”string”
```

#### var_dump()：显示完整信息

输出变量的“完整信息”，包括变量类型，长度（如果需要），内容

```php
$v1 = 12;
$v2 = true;
var_dump($v1);
var_dump($v2);

//输出
int(12)
bool(true)
```



#### 判断是否为某一种类型

- is_int() / is_integer()：判断是否为**整数**类型
- is_float()：判断是否为**浮点**类型
- is_bool()：判断是否为**布尔**类型
- is_string()：判断是否为**字符串**类型
- is_array()：判断是否为**数组**类型
- **is_numeric()：**判断是否为**“数字”**类型（含整数，小数，以及**“纯数字字符串”**）
- is_object()：

#### 两个特殊判断 isset() & empty()：

- **isset()**： 判断一个变量是否存在，或变量中是否有数据，有则返回true，否则返回false。
  - 如果变量中**有数据**，**返回true**
  - 如果变量中**没有数据**，**返回false**
- **empty()**：判断是否为“空的”。如果确实是“空的”，返回true，否则返回false。
  - 如果变量中的**数据为空**的，**返回true**
  - 如果变量中的**数据不是空**的，**返回false**



**空：**

0， 0.0， “”， “0”， false， array(),  	 //这几项，empty判断的结果都是**true**

**真空：**null		//表示完全不存在



### 类型转换

#### 自动转换

程序会根据运算时运算符所需要的数据类型进行转换

- 转换为数字：
  - **1+”2”           //3**
  - “1” + “2”         //3
  - **1 + ”2abc”       //3**
  - **1 + ”2abc34”     //3**
  - **1 + “abc”         //1**
  - **1 + “abc2”       //1**
  - 1.2 + “2.2abc”     //3.4
  - 1.2 + “abc2.2”     //1.2
  - “1.2abc” + “2abc” //3.2

规律：一个字符串当做数字，就会**将该字符串的最前面的数字转换为数字值**，如果没有，就为0

- 转换为整数（直接保留整数部分）：
  - 10.8 % 3.6
  - “10.8” % “3.6”
  - “10.8” % “3.6abc”
  - “10.8ab” % “3.6cd”



#### 强制转换

人为使用强转换语法进行转换，比如：

- $v1 = (int) “1”;		//结果，$v1是整数类型的1
- $v2 = (float) “1.23”;        //结果，$v2是浮点类型的1.23
- $v3 = (string) $v1;        //结果，$v3是字符串“1”



## 运算符

### 赋值运算符

将等号（=）右边的数据（可能是运算结果数据）赋值给左边的变量

$v1 = 1;

注意：**一个等号的左边，只能是一个“变量名”！**所以，这个写法是错误的：  $v1+2 = $v2 + 3



### 算术运算符

%：对整数数字进行“取余操作”——如果不是整数，会先自动转换为整数之后再进行取余。

**转换为整数的做法是：直接去掉小数部分**

$v2 = 10.8 % 3.6	  //结果为1



### 连接运算符

.：将前后字符串连接起来，如果不是字符串，会自动转换为字符串。

$v1 = “ab” . 12;     //’ab12’

$v2 = $v1 . “ef”;      //’ab12ef’

$v3 = “24” . true;   	//“241”，true转为字符串，为“1”；



### 自赋值运算符

+=  	-= 	 *= 	 /= 	 %= 

$变量 += 数据；

相当于这个赋值语句： $变量 = $变量 + 数据；



### 自操作(自加自减）运算符

针对数字，只有2个：	++ 	 -- 

属于单目运算符，即只要一个变量就可以进行运算。

- 形式：
  - $变量++；  //对该变量中数据+1
  - $变量--；   //对该变量中数据-1
  - ++$变量；  //对该变量中数据+1
  - --$变量；   //对该变量中数据-1

++：表示对该变量进行“自加1”操作。即该变量中的数据加1。

- 前自加：先自加，后取值；

- 后自加：先取值，后自加；

**区别：**

```php
$m1 = 10;
$m2 = 10;
$s1 = $m1++;	//先取值，后自加，再去进行其他运算
$s2 = ++$m2;	//先自加，后取值，再去进行其他运算

echo "<br>此时m1为：$m1", ", s1为：$s1";		//此时m1为：11，s1为：10
echo "<br>此时m2为：$m2", ", s2为：$s2";		//此时m1为：11，s1为：11

echo "<br>m1：$m1", $m1++ + 5;		//m1：16
echo "<br>m2：$m2", ++$m1 + 5;		//m2：17
```

**总结：**

1. 前自加，后自加，不改变最后变量的结果，都是加1

2. 但前自加、后自加如果跟别的运算符一起运行，此时区别为：

   - 前自加：先自加，后取值（然后去进行其他运算）；

   - 后自加：先取值，后自加（然后去进行其他运算）；



### 比较运算符

等于（\==）和全等于（\===）的区别：

- 等于（==）也会用“模糊相等”或“松散相等”的说法。两个数据“基本相等”（类型可能会发生自动转换），就算是相等。
  - 1 == “1”     //true
  - 0 == false;   //true
  - true == 1    //true
  - 2.0 == 2;   //true
- 全等于（===）就是完全相等。只有两个数据的数据类型一样，并且其值也一样的时候，才是全等。
  - 1 === “1”        //false
  - 0 === false;      //false
  - true === 1       //false
  - 2.0 === 2;      //false
  - 1 !== “1”         //true
  - 0 !== false;       //true
  - true !== 1        //true
  - 2.0 !== 2;      //true



### 逻辑运算符

针对“布尔值”进行的运算，只有3个： 

- 与：    &&  	//一假则假

- 或：    ||       //一真则真

- 非：    ！       //“取反”操作

按照真值表进行判断b



### 逻辑运算的短路规则

**逻辑运算的短路：**可能只进行左侧的逻辑判断之后，立即就中断后续（右侧）的判断，就称为短路

**结论：**

相对简单的运算放前面（左侧），相对复杂的运算放后面（右侧），可以提高代码效率



### 条件运算符

**语法为：**

**表达式1 ？ 表达式2 ：表达式3**

**含义：**

如果表达式1为true（或自动转换后为true），则运算的结果值为表达式2，否则为表达式3

**例子：**

```php
$score = 77;  //分数

$v1 = $score >= 60 ? “及格” : “不及格”;     //结果为”及格”
```

其本质是：

```php
$score = 77;	//分数
if  ( $score  >= 60 ){
$v1 = “及格”;
}
else{
$v1 = “不及格”;
}
```



### 位运算符（了解）

针对整数进行二进制级别的运算，因此只针对二进制的0和1这两个数据的基本位运算规则

**基本位运算符包括：**按位与（ & ）， 按位或（ | ）， 按位非（ ~ ）， 按位异或（^）

按位异或（^）：

- 0 ^ 1 结果为：1
- 0 ^ 0 结果为：0
- 1 ^ 0 结果为：1
- 1 ^ 1 结果为：0

**规则是：相同为0，不同为1**



#### 整数的按位与（&）运算

是针对整数的二进制值进行的位运算结果



例如：

**$v1 = 6 & 8;**  

这里，虽然是普通整数，但其内部是按该整数的二进制形式进行位运算

运算规则：

将6和8的二进制数字的每一个对应位上的数字（0或1)进行基本的按位与（&）的运算所得到的结果

| 数字6的二进制 |  0   |  0   |  0   | 0    |  0   |  0   |  1   |  0   |
| ------------- | :--: | :--: | :--: | ---- | :--: | :--: | :--: | :--: |
| 数字8的二进制 |  0   |  0   |  0   | 0    |  1   |  0   |  0   |  0   |
| 按位与结果    |  0   |  0   |  0   | 0    |  0   |  0   |  0   |  0   |



#### 按位左移运算 <<

同理可得右移

**$v1 = 8 << 2;** 

8是要进行左移运算的整数，2是表示要进行移动的位数。

将8这个数的二进制形式的数字的所有位都往左边移动2位，最右边空出部分填0（补0），最左边部分就会有2位“冒出去”了，也不要处理（不管），这样移动后，所得到的二进制数就是结果。

| 8的二进制    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 左移两位后： | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    |

结果：1 * 2 ^ 6 = 32

**总结：**

将一个整数左移n位，就是相当于**将该数乘以2的n次方！！！**



### 错误抑制符@

在一个表达式出现错误的时候，可以将错误“隐藏”（掩盖）起来（不输出）！

（只是该错误不显示，不是没有错误了）！！！



**实际用法：**

用于在实际运行环境中的一些条件不是与我们（程序员）所能控制的情形，我们可以抑制该错误的显示（只是该错误不显示，不是没有错误了）！！！



### 运算符的优先级

1. 时刻意识到，运算符有优先级问题！
2. 小括号可以改变运算的顺序（即括号最优先）
3. **先乘除（以及取余）后加减**
4. 大致有如此优先级规则：**算术运算 > 比较运算 > 逻辑运算**
5. 赋值运算符通常都是最后（优先级最低）



## 流程控制

### 三大流程结构

- **顺序结构**：
  - 程序运行的自然状态，就是从前往后（从上到下）运行程序。

- **分支结构**：
  - 程序运行过程中，根据判断条件的不同结果(true或false)，执行不同的分支（其他分支不再执行）。

- **循环结构**：
  - 程序运行过程中，根据判断条件的不同结果(true或false)，决定是**再次执行**还是**不再执行**。



### if 分支语句

#### 单分支

**结构：**

```php
if ( 条件判断 )

{

//如果条件满足，就执行这里

}
```

#### 双分支

**结构：**

```php
if (  条件判断 )
{
//如果条件满足，就执行这里
}
else
{
//如果条件不满足，就执行这里
}

```

#### 多分枝

**结构：**

```php
if (  条件判断1 )
{
//分支1；
}
elseif(  条件判断2 )
{
//分支2；
}
elseif(  条件判断3 )
{
//分支3；
}
else
{
//都不满足的分支   
}
。。。。。。。前面的elseif分支，可以若干个（0个以上）

```



### switch 分支语句

**语法：**

```php
switch( 一个变量数据或表达式结果$v1 )
{
    case  值1:			//如果$v1 等于 这个“值1”，就执行本分支
		分支语句A;
		break;			//表示跳出该分支，也就是跳出switch语句。
    case  值2:			//如果$v1 等于 这个“值2”，就执行本分支
		分支语句B;
		break;
    case  值3:			
    case  值4:			
		分支语句C;		//如果$v1 等于 “值3”或“值4”，就执行本分支
		break;
	。。。。。。		//可以更多的分支
    default:
		默认分支;		//前面都不满足的时候，就执行这里，default分支也可以不写
}
```



**说明：**

1. 上述“值1，值2，。。。”可以是各种标量类型，也可以是表达式——因为最终它也是一个值。
2. 用于进行测试的数据变量$v1跟后续的各个值，只能进行“相等比较”（==）。
3. 从上述第2条角度来说，其实际上不如if灵活。
4. **实际上，只判断值是否相等，相等就执行语句，不够灵活**



**注意：**

当某个分支满足条件并执行该分支后，如果该分支中**没有break语句**，此时，程序的流程会“直接进入”后一个分支**继续执行**，直到**碰到break才会结束switch**。



### while 循环语句

**语法：**

```php
$n1 = 10;
while( $n1 > 5 )		//条件判断
{
    echo "$n1";
。。。。循环体语句;
    $n--;		//循环改变量
}
```

**如果成立**，就执行循环体，而后会自动回到循环开始位置继续进行条件判断，如此反复

**如果不成立**，就退出循环执行后续语句



### do while 循环语句

**语法：**

```php
$n2 = 7
do 
{
    echo "$n2";
。。。。循环体语句;
	$n2++;
}while( $n2 <= 177 );		//条件判断
```

**注意：**先执行一次循环体，然后进行条件判断。因此至少做一次循环！



**提示：**

1，不管是while，还是dowhile，都请先写出一个良好的可运行的循环结构！

2，通常，循环体内的最后位置写循环变量的改变语句；



### for 循环语句

**语法：**

```php
for(循环变量初始化1; 循环条件判断2; 循环变量的改变3){
。。。。。。。。循环体语句块4;
//这里可以有多条语句
//是可以反复执行的部分
}
```

1. 此语句结构是将循环的3个要素都集中在一起写的形式，比较紧凑，容易控制，最常用。
2. 循环变量初始化语句1只执行一次，所以真正的正常循环，是在“2>4>3”之间进行



**例子：**

1、求1-100之间能被7整除的数的和

```php
$sum = 0;
for ($n = 1; $n <= 100; ++$n)
{
    if ($n % 7 ==0)
    {
        $sum += $n;
    }
}
```



### 多重循环及案例

输出如下形式的数字到页面上：

1 2 3 4 5 6 7 8；

2 2 3 4 5 6 7 8；

3 2 3 4 5 6 7 8；

4 2 3 4 5 6 7 8；

```php
for ($n1 = 1; $n1 <= 4; $n1++)
{
    echo "<br>$n1";
    for ($n2 = 2; $n2 <= 7; $n2++)
    {
        echo "$n2";
    }
    echo "8; ";
}
```



#### 九九乘法表

```php+HTML
<table border="1" width="700" height="200">
<?php
	for ($i = 1; $i <= 9; $i++)
    {
        echo "<tr>";	//输出行
        for ($k = 1; $k <= $i; $k++)
        {
            $s = $k*$i;
            echo "<td>{$k}X$i=" . $k*$i . "</td>";
        }
        echo "</tr>";
    }
?>
</table>
```



#### 百钱百鸡

公鸡5元一只，母鸡3元一只，小鸡1元3只，100元买了100只鸡，问各买了多少只？

##### 穷尽法

```php
for($gongji = 0; $gongji <= 100/5; $gongji++)
{
    for($muji = 0; $muji <= 100/3; $muji++)
	{
    	for($xiaoji = 0; $xiaoji <= 100; $xiaoji++)
		{
    		if($gongji + $muji + $xiaoji = 100 && $gongji*5 + $muji*3 + $xiaoji/3 == 100){
                echo "<br>公鸡:$gongji, 母鸡:$muji, 小鸡:$xiaoji";
            }
		}
	}
}
```

##### 改进1：

```php
for($gongji = 0; $gongji <= 100/5; $gongji++)
{
    for($muji = 0; $muji <= (100-$gongji*5)/3; $muji++)
	{
        $xiaoji = 100 - $gongji -$xiaoji;
    	if($gongji*5 + $muji*3 + $xiaoji/3 == 100){
            echo "<br>公鸡:$gongji, 母鸡:$muji, 小鸡:$xiaoji";
         }
	}
}
```

##### 改进2：

```php
for($gongji = 0; $gongji <= 100/5; $gongji++)
{
    for($muji = 0; $muji <= (100-$gongji*5)/3; $muji++)
	{
        $xiaoji = 100 - $gongji -$xiaoji;
        if($xiaoji % 3 != 0)
        {
            continue;	//算的整数，因此小鸡的数量是3的倍数，直接退出这一次计算
        }
    	if($gongji*5 + $muji*3 + $xiaoji/3 == 100)
        {
            echo "<br>公鸡:$gongji, 母鸡:$muji, 小鸡:$xiaoji";
         }
	}
}
```



### 循环的两种中断

#### continue 中断：

含义：中断当前正在进行的循环体（即后续语句不再执行），**继续下一次循环**要执行的语句

```
continue  [$n];		//表示是要中断第几层的循环，继续该层循环的下一次。
					//其中$n可以省略，如果省略，表示1，就是中断当前层的循环
```



#### break 中断：

含义：停止（跳出）当前正在进行的循环（即**完全终止循环**），去执行该循环之后的语句。

```
break  [$n];			//表示是要中断几层循环。
						//其中$n可以省略，如果省略，表示1，就是中断当前循环
```



#### 中断层次

从本循环向外计算层数

```
for(....)		//循环1
{
    for(...)	//循环2
    {
        for(...)	//循环3
        {
            break  ;		//中断循环3
            break  1;		//中断循环3
            break  2;		//中断循环2
            break  3；	//中断循环1
            //continue道理一样！
        }
        break	1;		//中断循环2
        break   2;		//中断循环1
    }
    break	1;		//中断循环1
}
```



#### 示例

```php
for($i=1; $i <= 10; $i++)
{
    if($i % 3 == 0)
    {
        continue;
    }
    elseif($i % 9 == 0)
    {
        break;
    }
    echo "$i,";
}
echo "<br>$i";

//结果
1,2,4,5,7,8,10,
11
//continue和break交换后，结果为
1,2,4,5,7,8,
9
```



## 函数

### 函数的定义与调用

```
function  函数名（$形参1，$形参2， ...... ）{  //形参，就是形式参数，是变量
	函数体语句块；  //就是若干行代码
}

调用语法形式：
函数名（$实参1，$实参2， ...... ）；	//实参就是实际参数，是数据
```

**说明**：

1，函数名的命名规则，跟变量名一样；

2，定义函数的目的就是为了以后能够调用；

3，调用函数，其实就是执行函数中代码；

4，**形参**，其实就是变量，是只能在该函数内部使用的变量；

5，**实参**，其实就是数据，是会传入函数内部的数据（是一一对应地**赋值**给形参变量）；

```
定义：
function xxx($i)
{
	for($i = 1; $i <= $n; $i++)
	{
		echo "<hr>";
	}
}

调用：
<?php
	xxx(4);
?>
```



### 函数的参数

- 形参&实参
- 形参的默认值



### 函数返回值return

一个函数在执行结束时，可以让其返回一个数据，这就是函数的返回值

```
return 要返回的数据;
```

说明：

1. 一般情况下一个**函数执行结束都是需要返回一个数据值**的
2. 函数也可以**在执行的中途返回数据**，此时，**函数也是结束了**的
3. 一个函数执行得到的返回值，可以在任何需要数据的场合使用，跟使用一个变量数据一样

只要函数中出现了return，函数就结束了

```
function f1($p1, $p2)
{
	$s1 = $p1 + $p2;
	return $s1;
	$s2 = $p1*$p1 + $p2*$p2;
	return $s2;
}

$result1 = f1(1, 2) + 3;	//f1(1, 2)就是一个数据3，因此可以进行计算
echo "<br>$result1 = $result1";

//输出：$result1 = 5
```

**因此，return有两个作用，一个用于返回值，另一个直接return结束语句**



### 可变函数

所谓可变函数，就是**函数名是一个变量**的情形。

可变函数实际上就是在**调用函数的时候，使用一个变量来表示函数名**，并用该变量去调用函数。

**注意：定义函数的时候，不可以使用可变函数名！**

```php
function do_jpg($f){
    echo "<br>处理jpg图片"
}
function do_gif($f){
    echo "<br>处理gif图片"
}
function do_png($f){
    echo "<br>处理png图片"
}

$file = $_GET['file_name'];		//获取用户上传的文件名，如123.jpg
$houzhui = strrchr($file, '.');	//获得后缀，'.jpg','.png'
$houzhui = substr($houzhui, 1);	//清洗获得后缀，'jpg','png'

$func_name = "do_" . $houzhui;	//构建出可以使用的函数名
$func_name( $file );			//执行函数
```



### 匿名函数

就是一个“定义时没有名字”的函数

```php
定义
$f1 = function   (形参...) {  .......  }；		//这是定义匿名函数的形式

调用
$f1(实参);	//这就是调用该调用。可见其调用，跟可变函数的写法非常类似
```

栗子

```php
//定义一个匿名函数，该函数可以计算两个数的最小公倍数
$war = function($n, $m){
    for($i = $n; $i >= $n; $i+=$n){
        if($i % $m == 0)
        {
            return $i;
        }
    }
};								//分号

$result1 = $war(3, 5);	
echo "<br>$result1 = $result1"	//15
```





























### 常见系统函数

#### strrchr(haystack, needle)

该函数返回**haystack**字符串中的一部分，以**needle最后出现的位置开始**，到**haystack末尾**

```
strrchr("acebfsnfa", 'f');		//返回'fa'
```



#### substr($v1, 位置p, [长度n])

取出字符串$v1中，位置从p开始之后的n个字符，n可以省略（表示取值到最后）

```
substr('abcdef', 3, 3);			//'def'	
substr('abcdef', 3, 10);		//'def'	
substr('abcdef', 3);			//'def'	
```

