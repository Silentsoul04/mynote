#  Python

[TOC]



## 基础

### 换行

\n

### 原始字符

​	只要在字符串前边加一个英文字母**r**即可，可以用来输出特殊字符,此处例如“\”

```
name = r'C:\Programe Filshc'
```

\：反斜杠，转义字符

### 长字符串

```
“”“
中间的文字
会
自动
换行
”“”
```



## 条件语句&循环语句

### 条件语句



### 循环语句

break,continue

## Python数值类型

### e记法

表示10的几次方

例如：

15e10	150000000000.0	输出是浮点型

### 判断数据类型

判断数据类型 isinstance(判断的变量1,判断的变量2或数据类型例如str)



## 常用操作符

### 算数操作符

以下假设变量： **a=10，b=20**：

| 运算符 | 描述                                            | 实例                                               |
| :----- | :---------------------------------------------- | :------------------------------------------------- |
| +      | 加 - 两个对象相加                               | a + b 输出结果 30                                  |
| -      | 减 - 得到负数或是一个数减去另一个数             | a - b 输出结果 -10                                 |
| *      | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 200                                 |
| /      | 除 - x除以y                                     | b / a 输出结果 2                                   |
| %      | 取模 - 返回除法的余数                           | b % a 输出结果 0                                   |
| **     | 幂 - 返回x的y次幂                               | a**b 为10的20次方， 输出结果 100000000000000000000 |
| //     | 取整除 - 返回商的整数部分（**向下取整**）       | `>>> 9//2 4 >>> -9//2 -5`                          |

### 比较操作符

以下假设变量a为10，变量b为20：

| 运算符 | 描述                                                         | 实例                                     |
| :----- | :----------------------------------------------------------- | :--------------------------------------- |
| ==     | 等于 - 比较对象是否相等                                      | (a == b) 返回 False。                    |
| !=     | 不等于 - 比较两个对象是否不相等                              | (a != b) 返回 true.                      |
| <>     | 不等于 - 比较两个对象是否不相等。**python3 已废弃。**        | (a <> b) 返回 true。这个运算符类似 != 。 |
| >      | 大于 - 返回x是否大于y                                        | (a > b) 返回 False。                     |
| <      | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 | (a < b) 返回 true。                      |
| >=     | 大于等于 - 返回x是否大于等于y。                              | (a >= b) 返回 False。                    |
| <=     | 小于等于 - 返回x是否小于等于y。                              | (a <= b) 返回 true。                     |

 

### 逻辑操作符

Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| :----- | :--------- | :----------------------------------------------------------- | :---------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

### Python赋值运算符

以下假设变量a为10，变量b为20：

| 运算符 | 描述             | 实例                                  |
| :----- | :--------------- | :------------------------------------ |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符   | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a               |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符     | c **= a 等效于 c = c ** a             |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a             |

### Python位运算符

按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：

下表中变量 a 为 60，b 为 13，二进制格式如下：

```
a = 0011 1100

b = 0000 1101

-----------------

a&b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
```

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由 **<<** 右边的数字指定了移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，**>>** 右边的数字指定了移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

### Python成员运算符

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

| 运算符 | 描述                                                    | 实例                                              |
| :----- | :------------------------------------------------------ | :------------------------------------------------ |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |

### Python身份运算符

身份运算符用于比较两个对象的存储单元

| 运算符 | 描述                                        | 实例                                                         |
| :----- | :------------------------------------------ | :----------------------------------------------------------- |
| is     | is 是判断两个标识符是不是引用自一个对象     | **x is y**, 类似 **id(x) == id(y)** , 如果引用的是同一个对象则返回 True，否则返回 False |
| is not | is not 是判断两个标识符是不是引用自不同对象 | **x is not y** ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 |

### Python运算符的优先级

以下表格列出了从最高到最低优先级的所有运算符：

| 运算符                   | 描述                                                   |
| :----------------------- | :----------------------------------------------------- |
| **                       | 指数 (最高优先级)                                      |
| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| * / % //                 | 乘，除，取模和取整除                                   |
| + -                      | 加法减法                                               |
| >> <<                    | 右移，左移运算符                                       |
| &                        | 位 'AND'                                               |
| ^ \|                     | 位运算符                                               |
| <= < > >=                | 比较运算符                                             |
| <> == !=                 | 等于运算符                                             |
| = %= /= //= -= += *= **= | 赋值运算符                                             |
| is is not                | 身份运算符                                             |
| in not in                | 成员运算符                                             |
| not and or               | 逻辑运算符                                             |

### 条件表达式——三元操作符

```python
x, y = 4, 5
if x < y:
	small = x
else:
	small = y

可以改进为：
small = x if x < y else y
条件在中间，真在左，假在右
```

## 断言

assert 称为“断言”，当关键字后条件为假时，程序自动崩溃，报AssertionError的异常

可以在程序中置入检查点，当有问题时及时“刹车”，确保程序的正常工作

## 列表&元组

### 列表

#### 创建一个列表

```
list = ['鹿羽','电风扇','鹿野修哉',12,['还可以添加一个列表再一个列表里','36']]		#允许不同类型的元素一起添加
thank = []		#也可直接定义一个空列表
```

#### 列表添加元素

##### append()

添加，只能加一个

```
list.apped('Antlers')
```

##### extend()

扩张，可以加多个；注意：添加的对象是一个列表

```
list.extend(['小可爱'，'老可爱'])
```

##### insert()

有两个参数，可以选择添加到列表的某一位置

```
list.insert(1,'玉米')		#插入到第2个位置
```

#### 从列表获取元素

##### 直接列表+索引

```
list[2]		#选取第3个元素
```

##### 列表分片（列表切片）获取多个值

一次性获取列表里的多个值

```
fruit = ['草莓','西瓜','菠菜','蓝莓','苹果']
fruit[1:3]	#获取索引从1到3的元素，['西瓜'，'菠菜']，包左不包右
fruit[:3]	#默认从0开始
fruit[::2]	#2可以理解成步长
```

#### 删除列表元素

##### remove()

以**元素的名称**来进行删除，如果元素名称没有输入正确，系统报错。

```
list.remove('小可爱')
```

##### del

不是一个函数，不是一个方法，是一个语句

```
fruit = ['草莓','西瓜','菠菜','蓝莓','苹果']
del fruitr[2]	#删掉菠菜
del fruit	#会删掉整个列表
```

##### pop()

python是利用**“栈”**，这种数据结构进行存储

```
fruit = ['草莓','西瓜','菠菜','蓝莓','苹果']
fruit.pop()		#会删掉最后一个元素‘苹果’
fruit.pop(2)	#也可以带参数，去掉第3个元素
```

#### 其他

dir()		#列举对象的所有可以使用的属性

count()		#查看列表里元素出现了多少次

index()		#索引列表里元素出现的位置

reverse()		#颠倒列表顺序，没有参数

sort()		#对列表元素进行排序，默认按从小到大排序，带参数reverse=Ture，由大到小

#### 列表的拷贝

可以用

```
list1 = [1,2,37,3,6,7]
```

以下的三种拷贝都不一样

```
list2 = list1
```

```
list3 = list1[:]
```

```
list4 += list1
```

​		第一种是类似**”贴标签“**，表示这个数组同时贴上了”list1“，”list2“这两个标签，也即一个数组有两个名字。当更改其中一个数组时，另一个数组也会同步操作，类似于**”软链接“**或者**”指针“**

​		第二种是一种拷贝，于第三种类似，更改其中一组不会对其他组造成影响

### 元组

元组不可修改

#### 创建一个元组

小括号不是关键，有逗号就可以

```
tuple = (1,2,3,4,5,6,7,8,9)
tuple2 = 24，36，48
tuple3 = ()		#创建一个空的元组
tuple4 = (16,)		#一个元素要加逗号
```

#### 增加元组元素

切片再组合  

```
temp = ('CPU','主板','硬盘','机箱','显卡')
temp = temp(:2) + ('内存',) + temp(2:)	#用切片的方法再元组内添加元素，注意逗号
```

#### 删除元组元素

```
temp = ('CPU','主板','内存','硬盘','菠萝','机箱','显卡')
temp = temp(:4) + temp(5:)		#删除'菠萝'
del temp	#删除整个元组
```

## 字典&集合

### 字典

键（key）值（value）对的映射

在一个字典中，**键是唯一**的，**且不可更改**，这意味着列表不可以为字典中的键，而**字符串**，**元组**，另一个**字典**等都可以为字典的一个键

值是可以重复的，可以是**任何数据类型**作为一个值

```
dict1 = {'A':a, 'B':b, 'C':c, 'D':d, 'E':e, 'F':f}
```

#### fromkeys	单次添加字典

重新创建一个新的字典，集体设置值

```
dict1 = {}
dict1.fromkeys((1,2,3), 'Number')

#输出：{1: 'Number', 2: 'Number', 3: 'Number'}



#以下行为不可以：
dict1.fromkeys((1,2,3), ('one','two','three'))

#这样会输出：{1: ('one', 'two', 'three'), 2: ('one', 'two', 'three'), 3: ('one', 'two', 'three')}



#试图修改其中1，3的值
dict1.fromkeys((1,3), '数字')

#但是会输出{1: '数字', 3: '数字'}
```



#### key()，values()，items()，get()

key()：返回字典的键

values()：返回字典的值

items()：以元组的形式返回一对键值对

get()：输入键，返回字典对应的值，如果没有**不会报错**，如果没有找到，  仅**返回none**，并且还可以自定义没有找到之后返回的值

```
dict1.get(32, '木有！')
```

可以用成员操作符（**in**，**not in**）检查键的成员资格，这样会更高效，注意的是：此处是**查找的是键**而不是值

#### setdefault()	选择性添加

输入**一个键**，如果在字典中找到了，就会返回对应的值；反之则会**添加一个值为none的键值对**

输入**一个键值对**，如果输入的键在原字典中存在一个一样的键，则会返回对应的值，且**不能更改**此时输入的**新对应的值**，反之则会**添加一个键值对**

```
dict2 = {1:'数字',2:'数字'}
print(dict2.setdefault(1,'数字'))
print(dict2.setdefault(2,'two'))
print(dict2.setdefault(5,'five'))
print(dict2)


#输出：
数字
数字
five
{1: '数字', 2: '数字', 5: 'five'}
```

#### update()	用字典更新字典

用一个字典或映射关系去跟新另外一个字典

```
a = {'小白': '狗', '小黑': '猪', 'antlers': '鹿'}
b = {'小白': '狐狸'}
a.update(b)
print(a)

#输出：
{'小白': '狐狸', '小黑': '猪', 'antlers': '鹿'}
```



#### clear()	清空

clear()：用于清空一个字典，但不是删除这个字典

#### pop()	删除



### 集合

在定义时，集合内的元素是唯一的，即使定义时重复了，python也会剔除重复元素，同时会**按一定的顺序排列**

**定义：**

```
num1 = {1,2,3,4,5,6,7,8}

set1 = set([1, 2, 3, 4, 5, 6, 7])
```

**注意：**集合不支持索引

#### 利用集合的性质来去除列表重复的元素

**循环方法：**

```
num = [1, 2, 3, 4, 6, 7, 7, 4, 1, 0]
temp = []
for each in num:
    if each not in temp:
        temp.append(each)

print(temp)

#输出：
[1, 2, 3, 4, 6, 7, 0]
```

**利用集合解决：**

```
num = [1, 2, 3, 4, 6, 7, 7, 4, 1, 0]
print(list(set(num)))

#输出：
[0, 1, 2, 3, 4, 6, 7]
```



#### 添加集合元素

```
num.add(10)
```



#### 不可变集合 frozenset()

使集合中的数据具有一定的稳定性 

```
num3 = frozenset([1,2,3,4,5])
num3.add(0)

#此时python会报错，不允许添加
```



## 格式化

**字符串格式化符号含义**

| **说明**                                   | **符号** |
| ------------------------------------------ | -------- |
| 格式化字符及其 ASCII 码                    | %c       |
| 格式化字符串                               | %s       |
| 格式化整数                                 | %d       |
| 格式化无符号八进制数                       | %o       |
| 格式化无符号十六进制数                     | %x       |
| 格式化无符号十六进制数（大写）             | %X       |
| 格式化浮点数字，可指定小数点后的精度       | %f       |
| 用科学计数法格式化浮点数                   | %e       |
| 作用同 %e，用科学计数法格式化浮点数        | %E       |
| 根据值的大小决定使用 %f 或 %e              | %g       |
| 作用同 %g，根据值的大小决定使用 %f 或者 %E | %G       |

格式化类似于**翻译**，其格式要求：

```
'%c %c' % (97, 100)		#按照%c的要求合并到前面的字符串中
'%d + %d = %d' % (4, 5, 4+5)		#输出4 + 5 = 9
'%x' % 10		#输出a
'%X' % 10		#输出A
'%f' % 27.233		#输出27.233000，默认精度是6位小数
```



**格式化操作符辅助命令**

| **符号** | **说明**                                                   |
| -------- | ---------------------------------------------------------- |
| m.n      | m 是显示的最小总宽度，n 是小数点后的位数                   |
| -        | 用于左对齐                                                 |
| +        | 在正数前面显示加号（+）                                    |
| #        | 在八进制数前面显示 '0o'，在十六进制数前面显示 '0x' 或 '0X' |
| 0        | 显示的数字前面填充 '0' 取代空格                            |

格式如下：

```
'%5.1f' % 27.233		#输出  27.2，前面有2个空格，保持5位总宽度
'%.2e' % 27.233		#输出2.72e+01
'%-10d' % 5		#输出5         ，后面用空格填充
```



**Python 的转义字符及其含义**

| **符号** | **说明**             |
| -------- | -------------------- |
| \'       | 单引号               |
| \"       | 双引号               |
| \a       | 发出系统响铃声       |
| \b       | 退格符               |
| \n       | 换行符               |
| \t       | 横向制表符（TAB）    |
| \v       | 纵向制表符           |
| \r       | 回车符               |
| \f       | 换页符               |
| \o       | 八进制数代表的字符   |
| \x       | 十六进制数代表的字符 |
| \0       | 表示一个空字符       |
| \\       | 反斜杠               |

## 序列

```
a = ('s','m','he',233)
len (a)		#sji
max()		min()
  
```

## 参数

### 形参&实参

简单来说，函数内的参数是形参，外面的是实参

### 关键字参数

调用参数时，在输入的参数前，标识函数内参数名，即使在输入时的位置不同，也可以正常调用

```
def app(name, age):
	print(name + age)

app(age='3', name='anitama')
```

### 默认参数

```
def haha(name='aaaaaaa', age='23'):
	print(name + age)
```

### 可变参数

```
#参数前添加*，表示可变参数，可以传入多个参数
def test(*parmas):
	print('参数的长度是：', len(parmas))
	print('第二个参数是：', parmas[1])
```

**注意：**如果需要同时使用其他的参数，则要在传参时用关键字参数进行传参

## 函数&过程

###  变量作用域

​		如果在函数内对全局变量进行修改，那么python会在函数内创建一个新的——相同名称的”局部变量“代替，且只能在函数内调用这个新的值，不会改变外面的全局变量

#### global 关键字

该关键字将在局部作用域内改变全局变量

```
num = 1
print(num)

def test():
    global num		#先进行初始化全局变量num
    num = 2		#再进行对全局变量的赋值
    print(num)

test()
print(num)
```

输出：

```
1
2
2
```

### 内嵌函数和闭包

#### 内部函数

内部函数只能在函数内被调用，无法被全局所调用

#### 闭包 cloces

从表现形式上定义为： 如果在一个**内部函数**里，对在**外部作用域**(但不是在全局作用域)的变量进行引用， 那么内部函数就被认为是闭包。

举个栗子：

```
def FunX(x):
    def FunY(y):
        return x * y

    return FunY


n = FunX(8)
print(type(n))
print(n(5))
#也可以
print(FunX(8)(5))
```

输出：

```
<class 'function'>
40
40
```

**注意：**当"n = FunX(8)"时，此时n变为一个函数，如果用到内部函数只需要n(5) 就可以调用FunY函数

此时：**n = FunX(8)；n(5)	=	FunX(8)(5)**

#### nonlocal 关键字

在闭包时，调用并改变闭包外的**非全局变量**的值

在python3中，新增该关键字用于局部变量，在局部函数内的函数因为无法找到变量而无法被调用

*nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。*

注意区分 **global** 和 **nonlocal** 

例如：

```
def nonlocal_test():
    count = 0

    def test2():
        nonlocal count
        count += 1
        return count

    return test2


val = nonlocal_test()
print(val())
```

输出：

```
1
```

### 匿名函数 lambda

不定义函数名，直接构建函数

普通函数：

```
def ds(x):
	return 2 * x + 1

print(ds(5))
```

 匿名函数：

```
g = lambda x : 2 * x + 1

g(5)
```

书写格式：lambda + 参数 ：函数的返回值

**作用：**

1. 使用lambda可以省下定义函数的过程，使代码更加精简
2. 对于比较抽象的程序，并且调用次数不多，可以节省考虑命名函数名的时间
3. 简化代码的可读性

### 内置函数

#### filter 过滤器

筛选出 ture ，1

例如奇数过滤：

```
def odd(x):
	return x % 2
	
temp = range(10)
show filter(odd,temp)

print( list(show) )

#输出[1, 3, 5, 7, 9]
```

或者：

```
a = list(filter(lambda x : x % 2, range(10)))
print(a)

#输出[1, 3, 5, 7, 9]
```

####  map 映射

将序列的每一个元素做为函数的参数进行运算加工，直到可迭代序列的每个元素都加工完毕，返回所有加工后的元素构成的新序列

人话：

1. 映射就是让指定的参数乖乖站好
2. 然后挨个进入指定的函数处理
3. 然后把运算后的值再排好队，挨个返回

```
b = list(map(lambda x : x * 2, range(10)))
print(b)

#输出[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```



## 递归&迭代

**递归就是函数自己调用自己**，具有危险性，内存资源占用较多，但几行语句就可以解决

**迭代**是为了逼近所需目标或结果，需要**反复执行子程序**，迭代资源占用少，但是有些问题迭代很难解决，同时代码行多，可阅读性差

### 阶乘

用递归思想设计阶乘函数

```
def factorial(n):
	if n == 1:
		return 1
	else:
		return n * factorial(n - 1)

n = int(input('请输入一个正整数：'))
print('{}的阶乘是：{}'.format(n, factorial(n)))
```



### 斐波那契数列

迭代方法实现

```
def haha(n):
    a = 1
    b = 1
    if n < 1:
        print( "输入有误！")
        return -1
    while (n - 2) > 0:
        a ,b = b , a + b
        n -= 1
    return b

print(haha(10))
```

 

递归方法实现

```
def buibui(n):
    if n < 1:
        print('输入有误！')
        return -1
    if n == 1 or n == 2:
        return 1
    else:
        return buibui(n - 1) + buibui(n - 2)

print(buibui(10)) 
```



### 汉诺塔

用递归方法实现

```
def hanoi(n, x, y, z):
	if n == 1:
		print(x, '-->', z)
	else:
		hanoi(n-1, x, z, y)		#将前n-1个盘子从x移到y上
		print(x, '-->', z)		#将最后一个盘子从x移到z上
		hanoi(n-1, y, x, z)		#将y上的n-1个盘子移动到z上

n = int(input('请输入汉诺塔的层数：'))
hanoi(n, 'x', 'y', 'z')
```



## 文件

### 打开文件 open

| 打开模式 | 执行操作                                                     |
| -------- | ------------------------------------------------------------ |
| r        | 以**只读**方式打开文件。文件的指针将会放在文件的开头。这是默认模式 |
| w        | 打开一个文件只用于写入。如果该文件已存在则打开文件，并会**覆盖已存在的文件**。如果该文件不存在，创建新文件 |
| x        | 写模式，新建一个文件，如果该文件已存在则会报错               |
| a        | 以写入模式打开。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被**写入到已有内容之后**。如果该文件不存在，创建新文件进行写入 |
| b        | 以二进制模式打开文件                                         |
| t        | 以文本模式打开 (默认)                                        |
| +        | 可读写模式，打开一个文件进行更新(可读可写)                   |
| U        | 通用换行模式（不推荐）                                       |

### 文件的读取与写入

| **文件对象方法**               | **执行操作**                                                 |
| ------------------------------ | ------------------------------------------------------------ |
| f.close()                      | 关闭文件                                                     |
| f.read([size=-1])              | 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回 |
| f.readline([size=-1])          | 从文件读取整行（以一行为单位进行读取），包括 "\n" 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 "\n" 字符 |
| f.write(str)                   | 将字符串str写入文件                                          |
| f.writelines(seq)              | 向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象 |
| f.seek(offset, from)           | 在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节 |
| f.tell()                       | 返回当前在文件中的位置                                       |
| f.truncate([size=file.tell()]) | 截取文件到size个字节，默认是截取到文件指针当前位置           |

每次读取都是会有类似**“书签”**——文件指针，每次读取默认会从上次末尾读取，可以用 **文件 参数.seek(0, 0)** 重新定位

**注意：**

1. list（）是从文件指针位置开始到末尾的，不是输出整个文档内容！
2. 写入前，请先确保打开文件时有写入的权限



## os，os.path 跨平台模块

Python是跨平台的语言，也即是说同样的源代码在不同的操作系统不需要修改就可以同样实现。

因此Python的作者就倒腾了OS模块这么一个玩意儿出来，有了OS模块，我们不需要关心什么操作系统下使用什么模块，OS模块会帮你选择正确的模块并调用。

**os模块中关于文件/目录常用的函数使用方法**

| **函数名**                                           | **使用方法**                                                 |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| getcwd()                                             | 返回当前工作目录                                             |
| chdir(path)                                          | 改变工作目录                                                 |
| listdir(path='.')                                    | 列举指定目录中的文件名（'.'表示当前目录，'..'表示上一级目录） |
| mkdir(path)                                          | 创建单层目录，如该目录已存在抛出异常                         |
| makedirs(path)                                       | 递归创建多层目录，如该目录已存在抛出异常，注意：'E:\\a\\b'和'E:\\a\\c'并不会冲突 |
| remove(path)                                         | 删除文件                                                     |
| rmdir(path)                                          | 删除单层目录，如该目录非空则抛出异常                         |
| removedirs(path)                                     | 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 |
| rename(old, new)                                     | 将文件old重命名为new                                         |
| system(command)                                      | 运行系统的shell命令                                          |
| walk(top)                                            | 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 |
| *以下是支持路径操作中常用到的一些定义，支持所有平台* |                                                              |
| os.curdir                                            | 指代当前目录（'.'）                                          |
| os.pardir                                            | 指代上一级目录（'..'）                                       |
| os.sep                                               | 输出操作系统特定的路径分隔符（Win下为'\\'，Linux下为'/'）    |
| os.linesep                                           | 当前平台使用的行终止符（Win下为'\r\n'，Linux下为'\n'）       |
| os.name                                              | 指代当前使用的操作系统（包括：'posix', 'nt', 'mac', 'os2', 'ce', 'java'） |



**os.path模块中关于路径常用的函数使用方法**

| **函数名**                     | **使用方法**                                                 |
| ------------------------------ | ------------------------------------------------------------ |
| basename(path)                 | 去掉目录路径，单独返回文件名                                 |
| dirname(path)                  | 去掉文件名，单独返回目录路径                                 |
| join(path1[, path2[, ...]])    | 将path1, path2各部分组合成一个路径名                         |
| split(path)                    | 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 |
| splitext(path)                 | 分离文件名与扩展名，返回(f_name, f_extension)元组            |
| getsize(file)                  | 返回指定文件的尺寸，单位是字节                               |
| getatime(file)                 | 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） |
| getctime(file)                 | 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） |
| getmtime(file)                 | 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） |
| *以下为函数返回 True 或 False* |                                                              |
| exists(path)                   | 判断指定路径（目录或文件）是否存在                           |
| isabs(path)                    | 判断指定路径是否为绝对路径                                   |
| isdir(path)                    | 判断指定路径是否存在且是一个目录                             |
| isfile(path)                   | 判断指定路径是否存在且是一个文件                             |
| islink(path)                   | 判断指定路径是否存在且是一个符号链接                         |
| ismount(path)                  | 判断指定路径是否存在且是一个挂载点                           |
| samefile(path1, paht2)         | 判断path1和path2两个路径是否指向同一个文件                   |



## pickle模块“泡菜罐”

将列表、元组和字典等数据类型转换成二进制文件，方便复用

### 创建一个二进制文件

```python
import pickle

city = ['北京','上海','武汉','广州','深圳','长沙','重庆']

pickle_file = open('city.pkl', 'wb')	//.pkl只是提醒的作用，不会影响具体写入的格式，wb是二进制文件的写入操作
pickle.dump(city, pickle_file)	//往pickle_file这个二进制“泡菜罐”倒入city
pickle_file.close()
```

### 调用一个二进制文件

```python
pickle_file = open('city.pkl', 'rb')	//wb是二进制文件的读取操作

china_city = pickle.load(pickle_file)
print(china_city)
```



## 异常处理 try语句

### try-exception

为的是提供用户看得懂的提示

如果没有使用这个异常处理机制的话，当运行到这个地方，出错了，程序会崩溃。

如果用了这个try，程序将不会崩溃，会继续执行后续语句，就是需要提前预知可能发生的错误，做好准备，try就会有应对措施

```python
try:
	f = open('为什么我是一个文件.txt')
    print(f.read())
    f.close()
except OSError as reanson:	//OSError是错误类型，需要提前预知
    print('文件出错了T_T\错误原因是：' + str(reanson))

except TypeError as reanson: 
    print('文件出错了T_T\错误原因是：' + str(reanson))

except OSError as (reanson,TypeError):	//也可以写成元组的类型
     print('文件出错了T_T')
    
//输出
文件出错了T_T
错误原因是：[Errno 2] No such file or directory: '为什么我是一个文件.txt'
```



### try-finally

常与try-exception一起使用，表示无论如何都会执行的代码

```python
try:
	f = open('为什么我是一个文件.txt', 'w')
    print(f.write('我存在了！'))
    sum = 1 + 'i'
	//f.close()

except TypeError as reanson:	//文件会因为整形和字符串无法相加而报错。因此无法执行close操作，导致文件内容无法被写入
    print('文件出错了T_T', + str(reanson))

finally:	//使用finally，会执行无论如何都会执行的代码，帮助我们执行一些必要的操作
    f.close()
```



### raise 让代码自己引起异常

```python
raise haha('就是对“haha”这个异常的解释哦！！！')
```



## else语句

