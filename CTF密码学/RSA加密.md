## RSA加密

**RSA属于非对称加密算法**，因为RSA使用了两个不同的密钥分别用于加密和解密，这**两个密钥称之为公私钥对**，其中**公钥用于加密，且公钥是公开的，而私钥用于解密，私钥是私有的**



> 1. 选择两个大素数p和q，计算出模数N = p * q
>
> 2. 计算φ = (p−1) * (q−1) 即N的欧拉函数，然后选择一个e (1<e<φ)，且e和φ互质
>
> 3. 取e的模反数为d，计算方法: e * d ≡ 1 (mod φ)
>
>    （模反元素：如果两个正整数e和n互质，那么一定可以找到整数d，使得 e * d - 1 被n整除，或者说e * d被n除的余数是1。这时，d就叫做e的“模反元素”。欧拉定理可以用来证明模反元素必然存在。两个整数a,b，它们除以整数M所得的余数相等：a ≡ b(mod m)，比如说5除3余数为2，11除3余数也为2，于是可写成11 ≡ 5(mod 3)。）
>
> 4. 对明文m进行加密：c = pow(m, e, N)，得到的c即为密文
>    $$
>    C=M^e\%n
>    $$
>    
>5. 对密文c进行解密，m = pow(c, d, N)，得到的m即为明文
>    $$
>    M=C^d\%n
>    $$
>    

整理一下得到我们需要认识和记住的参数

- p 和 q ：大整数N的两个因子(素数)（factor）
- N：大整数N，我们称之为模数（modulus）
- e 和 d：互为模反数的两个指数（exponent）
- c 和 m：分别是密文和明文，这里一般指的是一个十进制的数

然后我们一般称

- （N，e）：公钥
- （N，d）：私钥



### RSA安全性&破解

对于RSA加密算法，公钥`(N, e)`为公钥，可以任意公开，破解RSA最直接（亦或是暴力）的方法就是分解整数`N`，然后计算`欧拉函数φ(n)=(p-1) * (q-1)`,再通过`d * e ≡ 1 mod φ(N)`，即可计算出 `d`，然后就可以使用私钥`(N, d)`通过`m = pow(c,d,N)`解密明文。



### 常用的攻击方法

- #### 直接分解模数Ｎ

  直接分解模数N是最直接的攻击方法，也是最困难的方法，适用于n比较小的时候

  

- #### RSA的公共模数攻击

  **使用相同的模数 N 、不同的私钥，加密同一明文消息**

  假如采用两个或者两个以上的公钥(N,e)来加密同一条信息，可以得到下面的结论

  > c1 = pow(m, e1, N)
  > c2 = pow(m, e2, N)

  分别拿对应的私钥来加密，可以得到相同的明文`m`

  ```
  m = pow(c1, d1, N)
  m = pow(c2, d2, N)
  ```

  假设攻击者已知**n,e1,e2,c1,c2，即可可以得到明文m**，因为**e1和e2互质**，所以使用**欧几里得算法**（用于计算两个整数a,b的最大公约数）可以找到能够满足以下条件的x，y：

  ```
  pow(x,e1)+pow(y,e2)=1
  ```

  假设x为负数，需再使用欧几里得算法来计算

  ```
  pow(c1,-1)
  ```

  则可以得到，

  ```
  pow(pow(c1,-1),-x) * pow(c2,y) = p mod(n)
  ```

  如果p<n，则p可以被计算出来

  

- #### RSA小指数e攻击

  如果RSA系统的公钥e选取较小的值，可以提高加解密速度，但如果e的选取太小，就容易受到攻击

  有三个分别使用不同的模数n1,n2,n3，但是都选取e=3，加密同一个明文可以得到：

  > c1 = pow(m,3,n1)
  > c2 = pow(m,3,n2)
  > c3 = pow(m,3,n3)

  一般情况下，**n1,n2,n3互素**，否则会比较容易求出公因子，从而安全性大幅度的减低。

  

- #### 利用公约数

  如果两次加密的**n1和n2具有相同的素因子**，可以利用**欧几里德算法直接分解n1和n2**。
  通过欧几里德算法计算出两个n的最大公约数p：

  ```python
  def gcd(a, b):
  	if a < b:
      	a, b = b, a
  	while b != 0:
      	temp = a % b
       	a = b
       	b = temp
  def gcd_digui(a, b):
  	if b != 0:
     		return a
  	return gcd(b,a%b)
  
  p = gcd(n1,n2)
  ```

  这种题目通常会发现**题目给了若干个n，均不相同，并且都是2048bit，4096bit级别**，无法正面硬杠，并且明文都没什么联系，**e也一般取65537**

  直接分解成功。而欧几里得算法的时间复杂度为：O(log n)。这个时间复杂度即便是4096 bit也是秒破级别
  **根据欧几里德算法算出的p之后，再用N除以P即可求出Q，由此可以得到的参数有p、q、n、e，再使用常规方法计算出d，即可破解密文。**

  

- #### 低加密指数攻击

  在RSA中的e被称为加密指数。由于e的选择只需要满足以下条件即可

  > 计算欧拉函数 φ = (p-1) * (q-1)，然后选择一个e(1<e<φ)，并且e和φ互质

  选择小的e可以缩短加密时间，但是选择的e不当，可能会造成严重的安全问题。
  **e=3的小明文攻击**

  当e=3，并且明文过小时，导致明文的三次方仍然小于n，通过直接对密文三次开方，即可得到明文。
  原理如下

  > 对明文m进行加密：c = pow(m, 3, N),可以得到密文c。
  > 因为n > pow(m, 3)，所以c = pow(m, 3, N) = pow(m, 3)，故对密文三次开方，即可得到明文。

  有一种特殊的情况是：pow(m, 3) > n，但是不是足够，假设存在这样的k，有下列的公式成立：

  > c = pow(m, 3) + k * n

  爆破k，当且仅当c - (k * n)可以开三次方，c - (k * n)开三次方结果就是明文m。

  **识别**
  当e=3时，优先使用这种方法解密。

  ```python
  i=0
  while 1:
  	if(gmpy.root(c+i*N, 3)[1]==1):
  		 print gmpy.root(c+i*N, 3)
  		 break
  	i=i+1
  ```
  
- 维纳攻击，大e



### 常见题型

- #### 已知p、q、e求解d

  根据欧拉函数，可以通过p、q计算出欧拉函数值

  > φ(n) = (p-1) * (q-1)

  之后再根据以下的公式反推出`d`

  > d * e ≡ 1 mod φ(N)

  

- #### 已知p、q、e、c求解明文

  **思路**
  根据常规的思路，求解出明文`m`，必须通过通过以下的公式

  > m ≡ pow(c,d) mod n

  现在缺少的参数有d、n，其中的n可以通过以下的公式可以求出

  > n = p * q

  而`d`可以通过以下公式求出

  > d * e = 1 mod φ(n)
  > φ(n) = (p-1) * (q-1)

  

- #### 已知c、n、e求解明文

  **思路**
  先根据

  > n = p * q

  对已知的n进行大数分解得到p、q，一般通过在线或者自己通过脚本实现
  根据欧拉函数，可以通过p、q计算出欧拉函数值

  > φ(n) = (p-1) * (q-1)

  之后再根据以下的公式反推出d

  > d * e ≡ 1 mod φ(N)

  最后对密文c进行解密：m = pow(c, d, N)，可以得到明文m。

  

- #### 已知c、e，求解明文

  一般情况下，求解明文的公式为

  > m = pow(c, d, N)

  在仅已知c、e的情况下，几乎不能反推出其他的参数，python中提供一个Crypto的库，通过调用相关的函数模块，可以实现对n、e的求解，之后再通过分解大数n等方法，求出其他的参数。

  

  首先通过公钥文件public.pem获取n、e

  ```python
  # 通过公钥文件获取n、e
  from Crypto.PublicKey import RSA
  
  public = RSA.importKey(open("./RSA/public.pem").read())
  n = public.n
  e = public.e
  print("n=\n%s\ne=\n%s"%(n,e))
  12345671234567
  n=
  74207624142945242263057035287110983967646020057307828709587969646701361764263
  e=
  65537
  ```

  通过在线网站分解大数

  可以得到`p=258631601377848992211685134376492365269`以及`q=286924040788547268861394901519826758027`

  生成私钥

  ```python
  #python2
  
  from Crypto.PublicKey import RSA
  
  keypair = RSA.generate(1024)
  keypair.p = 258631601377848992211685134376492365269
  keypair.q = 286924040788547268861394901519826758027
  keypair.e = 65537
  keypair.n = keypair.p * keypair.q
  phi_n = (keypair.p-1) * (keypair.q-1)
  
  i = 1
  while (True):
          x = (phi_n * i ) + 1
          if (x % keypair.e == 0):
              keypair.d = x / keypair.e
              break
          i += 1
  
  private = open('private.pem','w')
  private.write(keypair.exportKey())
  private.close()
  ```

  最后使用生成的私钥将加密文件解密

  ```
  openssl rsautl -decrypt -in ./RSA/flag.enc -inkey private.pem -out flag.txt
  ```





